function h = planefield(x,y,u,v,panelshape)
% Creates a plane-field visually representing a one-form. This is
% data-equivalent to a quiver plot, but represents fields as sloped planes,
% rather than the vectors that capture the slope. x and y should be in the
% order generated by meshgrid.


% If no panel shape is specified, use rectangular panels
if ~exist('panelshape','var')
	panelshape = 'rectangle';
end

% First, generate a grid of the spacings between points in the grid
x_spacing = gradient(x);
[~,y_spacing] = gradient(y);

% Next, turn the x and y grids, their spacing, and the vector values into cells
x_cell = num2cell(x);
y_cell = num2cell(y);

x_spacing_cell = num2cell(x_spacing);
y_spacing_cell = num2cell(y_spacing);

u_cell = num2cell(u);
v_cell = num2cell(v);


%%%%%%%%%
% Generate panels differently for circle and rectangle panels

switch panelshape

	case 'rectangle'
		% Next, generate the four points of the plane, centered on the xpoint by
		% expanding around zero by half the spacing in each direction
		x_block_local = cellfun(@(b) b*[-1 1;-1 1]/2,x_spacing_cell,'UniformOutput',false);
		y_block_local = cellfun(@(b) b*[-1 -1;1 1]/2,y_spacing_cell,'UniformOutput',false);

	case 'circle'
		
		theta = linspace(0,2*pi,30);
		r = cellfun(@(a,b) linspace(0,min(a,b)/2,2),x_spacing_cell,y_spacing_cell,'UniformOutput',false);
	%	r = cellfun(@(a,b) min(a,b)/2,x_spacing_cell,y_spacing_cell,'UniformOutput',false);
		
		[polarTheta,polarR]...
			=cellfun(@(a) meshgrid(theta,a),r,'UniformOutput',false);
		
		
% 		x_block_local_intermediate...
% 			= cellfun(@(a,b) min(a,b)*cos(theta)/2,x_spacing_cell,y_spacing_cell,'UniformOutput',false);
% 		y_block_local_intermediate...
% 			= cellfun(@(a,b) min(a,b)*sin(theta)/2,x_spacing_cell,y_spacing_cell,'UniformOutput',false);
% 
		[x_block_local,y_block_local]...
			=cellfun(@pol2cart,polarTheta,polarR,'UniformOutput',false);
		
end

% Next, generate the z values at the block points
z_block = cellfun(@(a,b,c,d) a.*c+b.*d,x_block_local,y_block_local,u_cell,v_cell,'UniformOutput',false);

% Now center the local blocks on their grid values
x_block = cellfun(@(a,b) a+b,x_cell,x_block_local,'UniformOutput',false);
y_block = cellfun(@(a,b) a+b,y_cell,y_block_local,'UniformOutput',false);


% Pad the blocks with NaN values
x_padded = cellfun(@NaNpad,x_block,'UniformOutput',false);
y_padded = cellfun(@NaNpad,y_block,'UniformOutput',false);
z_padded = cellfun(@NaNpad,z_block,'UniformOutput',false);

% Merge the padded values into arrays
x_merged = cell2mat(x_padded);
y_merged = cell2mat(y_padded);
z_merged = cell2mat(z_padded);

h = surf(x_merged,y_merged,z_merged);

end


function padded =  NaNpad(unpadded)
% Pad a matrix with a ring of NaN values

	padded = NaN(size(unpadded)+2);
	padded(2:end-1,2:end-1) = unpadded;

end